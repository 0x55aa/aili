### 3.0.0

**Mass Tree**

1. 改进版的 B<sup>link</sup> Tree
2. （BUG）border 节点分裂时没有 fence key 截断，对应的，interior 节点下降时只有 keyslice 相等时，才能进行偏移的更新
3. （BUG）key 偏移更新问题。第二个 bug 是错的，只有当下降到 subtree 时，才需要进行 key 偏移的更新，同时只有当生成 subtree 时才需要进行截断
4. （BUG）节点下降时根据错误的映射关系获取了错误的节点
5. （BUG）获取节点信息的宏出现错误，没有更安全地加上括号
6. （BUG）分裂后将新节点插入父节点时，同时设置父节点，但如果父节点此时也分裂了，可能造成父节点设置错误



### 2.3.0

**将 level 0 节点从1/2满提高到2/3，即 B<sup>*</sup> Tree**
1. 更紧凑的节点布局，大幅节省节点内存。
2. 由于这个优化会带来新的 cache miss，并且需要额外的一些 CPU 计算，所以预计并不会对 palm tree 性能提升有帮助，甚至有可能下降？
3. 如果把当前节点的 key 挪过去了，那当前 worker 后续的 key 可能需要重新定向。（发现这个问题之前就解决了）
4. 也可能挪过去了会造成后续 key 插入时节点的 key 挪动，不过也可能可以避免当前节点后续 key 的移动，所以并不是一个问题。
5. 从之前的测试情况来看，4k节点从设计上来说是有问题的，因为瓶颈在 cache miss 上，而且4k节点在实现 b<sup>*</sup>node 时也带来了很大的问题，需要很多 CPU 计算。所以需要重新设计节点的结构，核心的改变是以 CACHE LINE(64 字节) 为单位，希望获得更好的 cache locality。
6. 这个优化和 Prefix B Tree 是冲突的
7. （BUG）单个节点发生多次 move 导致多个 key 需要被替换，会导致在 level 1 替换 key 时发现有的 key 不存在。所以需要进行 key 过滤
8. （BUG）两个节点同时往新节点移入 key 时没有修改 `next` 域
9. （BUG）右移时顺序错误
10. （BUG）统计可移入字节数时只统计了 key 的长度，没有统计其他域
11. （BUG）由于 key 的左移，导致无法只通过右移来确定实际插入的 level 0 节点
12. （BUG）顺序插入优化时没有连接新节点
13. 移除了顺序插入优化的标记 `sopt`
14. （BUG）当 replace fence key 到达父节点时，父节点已经发生了分裂，导致要被替换的 key 被提升到了父节点上层

**总结：**

* 随机插入性能稍有下降（<5%），顺序插入性能不受影响
* 节点占用内存减少约13%，但是目前没有优化彻底，所以没有达到预期效果，具体情况需要等待后续完成 palm tree 信息统计后才可以得知


### 2.2.0

**对 level 0 进行前缀压缩（Prefix B Tree）**

1. 为了简化编程暂不考虑 key 长度小于等于前缀的情况。
2. 对于写入时 prefix 不一致的问题，需要新分配节点来插入 key，是否会造成很多零碎节点？会有但并不是问题。
3. 优化效果十分良好，对于100万个10字节 key 会有8%以上的内存节省，随着 key 数量的增长内存节省会更明显。



### 2.1.0

**节点内存分配器**

1. 每个线程对应一个分配器，尽可能减少内存分配毛刺的出现，更加稳定。
2. 因为测试线程少，所以目前分配器并不会带来什么实际效果。
3. 是否可以考虑和 prefetch 相结合？
4. 是否可以引入新的以线程为单位的节点布局（CSB+ Tree）？