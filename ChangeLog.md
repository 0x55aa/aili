### 2.3.0
**将 level 0 节点从1/2满提高到2/3，即 B<sup>*</sup> node**
1. 更紧凑的节点布局，大幅节省节点内存。
2. 由于这个优化会带来新的 cache miss，并且需要额外的一些 CPU 计算，所以预计并不会对 palm tree 性能提升有帮助，甚至有可能下降？
3. 如果把当前节点的 key 挪过去了，那当前 worker 后续的 key 可能需要重新定向。（发现这个问题之前就解决了）
4. 也可能挪过去了会造成后续 key 插入时节点的 key 挪动，不过也可能可以避免当前节点后续 key 的移动，所以并不是一个问题。
5. 从之前的测试情况来看，4k节点从设计上来说是有问题的，因为瓶颈在 cache miss 上，而且4k节点在实现 b<sup>*</sup>node 时也带来了很大的问题，需要很多 CPU 计算。所以需要重新设计节点的结构，核心的改变是以 CACHE LINE(64 字节) 为单位，希望获得更好的 cache locality。
6. 这个优化和 Prefix B Tree 是冲突的
7. （BUG）单个节点发生多次 move 导致多个 key 需要被替换，会导致在 level 1 替换 key 时发现有的 key 不存在。所以需要进行 key 过滤
8. （BUG）两个节点同时往新节点移入 key 时没有修改 `next` 域
9. （BUG）右移时顺序错误
10. （BUG）统计可移入字节数时只统计了 key 的长度，没有统计其他域
11. （BUG）由于 key 的左移，导致无法只通过右移来确定实际插入的 level 0 节点
12. （BUG）顺序插入优化时没有连接新节点
13. 移除了顺序插入优化的标记 `sopt`

### 2.2.0

**对 level 0 进行前缀压缩**

1. 为了简化编程暂不考虑 key 长度小于等于前缀的情况。
2. 对于写入时 prefix 不一致的问题，需要新分配节点来插入 key，是否会造成很多零碎节点？会有但并不是问题。
3. 优化效果十分良好，对于100万个10字节 key 会有8%以上的内存节省，随着 key 数量的增长内存节省会更明显。



### 2.1.0

**节点内存分配器**

1. 每个线程对应一个分配器，尽可能减少内存分配毛刺的出现，更加稳定。
2. 因为测试线程少，所以目前分配器并不会带来什么实际效果。
3. 是否可以考虑和 prefetch 相结合？
4. 是否可以引入新的以线程为单位的节点布局（CSB+ Tree）？